{
  "actores": [
    {
      "nombre": "-actor-base",
      "codigo": "class ActorBase {\n  tipo: String;\n  sprite: Phaser.GameObjects.Sprite;\n  pilas: Pilas;\n  id_color: number;\n  figura = \"\";\n  sin_rotacion: false;\n  automata: Automata;\n  colisiones: Actor[];\n  sensores: any[];\n  _etiqueta: string = null;\n  _vivo: boolean = true;\n  _animacion_en_curso: string = \"\";\n  _figura_ancho: number;\n  _figura_alto: number;\n  _figura_radio: number;\n  _es_texto: boolean = false;\n  _texto: any;\n  texto: any;\n  _id: any;\n  _nombre: any;\n\n  proyecto: any;\n\n  _habilidades: any[];\n  _comportamientos: { nombre_del_comportamiento: string; argumentos: any }[];\n  _comportamiento_actual: Comportamiento = null;\n\n  _fondo: any = null;\n  _fondo_imagen: string = \"\";\n  _dialogo: any = null;\n  _fuente: string = \"color-blanco-con-sombra\";\n\n  _texto_con_borde: boolean = false;\n  _color_de_texto: string = \"white\";\n\n  propiedades_base = {\n    x: 0,\n    y: 0,\n    z: 0,\n    imagen: \"imagenes:basicos/sin_imagen\",\n\n    centro_x: 0.5,\n    centro_y: 0.5,\n    rotacion: 0,\n    escala_x: 1,\n    escala_y: 1,\n    transparencia: 0,\n    etiqueta: \"actor\",\n\n    espejado: false,\n    espejado_vertical: false,\n\n    figura: \"\",\n    figura_dinamica: true,\n    figura_ancho: 100,\n    figura_alto: 100,\n    figura_radio: 40,\n    figura_sin_rotacion: false,\n    figura_rebote: 1,\n    figura_sensor: false,\n\n    es_texto: false,\n    texto_con_borde: false,\n    color: \"white\"\n  };\n\n  propiedades: any = {\n    x: 0,\n    y: 0,\n    z: 0,\n    imagen: \"imagenes:basicos/sin_imagen\",\n    figura: \"\"\n  };\n\n  constructor(pilas) {\n    this.pilas = pilas;\n    this.automata = new Automata(this);\n    this.colisiones = [];\n    this._habilidades = [];\n  }\n\n  get propiedades_iniciales() {\n    return this.propiedades;\n  }\n\n  pre_iniciar(propiedades) {\n    let figura = propiedades.figura || \"\";\n\n    this._id = propiedades.id || this.pilas.utilidades.obtener_id_autoincremental();\n    this._nombre = propiedades.nombre;\n\n    this.sensores = [];\n    this._comportamientos = [];\n    this._figura_ancho = propiedades.figura_ancho;\n    this._figura_alto = propiedades.figura_alto;\n    this._figura_radio = propiedades.figura_radio;\n    this._es_texto = propiedades.es_texto;\n\n    switch (figura) {\n      case \"rectangulo\":\n        this.sprite = this.crear_sprite(\"matter\", propiedades.imagen);\n        this.figura = figura;\n\n        this.crear_figura_rectangular(propiedades.figura_ancho, propiedades.figura_alto);\n\n        this.dinamico = propiedades.figura_dinamica;\n        this.sin_rotacion = propiedades.figura_sin_rotacion;\n        this.rebote = propiedades.figura_rebote;\n        this.sensor = propiedades.figura_sensor;\n        this.sprite.body[\"es_dinamica\"] = this.dinamico;\n        this.sprite.body[\"es_sensor\"] = this.sensor;\n        break;\n\n      case \"circulo\":\n        this.sprite = this.crear_sprite(\"matter\", propiedades.imagen);\n        this.figura = figura;\n        this.crear_figura_circular(propiedades.figura_radio);\n\n        this.dinamico = propiedades.figura_dinamica;\n        this.sin_rotacion = propiedades.figura_sin_rotacion;\n        this.rebote = propiedades.figura_rebote;\n        this.sensor = propiedades.figura_sensor;\n        this.sprite.body[\"es_dinamica\"] = this.dinamico;\n        this.sprite.body[\"es_sensor\"] = this.sensor;\n        break;\n\n      case \"ninguna\":\n      case \"\":\n        this.figura = figura;\n        this.sprite = this.crear_sprite(\"sprite\", propiedades.imagen);\n        break;\n\n      default:\n        throw Error(`No se conoce el tipo de figura ${figura}`);\n    }\n\n    this.interactivo = true;\n\n    this.rotacion = propiedades.rotacion || 0;\n    this.id_color = this.generar_color_para_depurar();\n    this.etiqueta = propiedades.etiqueta;\n\n    this.escala_x = propiedades.escala_x || 1;\n    this.escala_y = propiedades.escala_y || 1;\n\n    this.tipo = propiedades.tipo;\n    this.centro_x = propiedades.centro_x || 0.5;\n    this.centro_y = propiedades.centro_y || 0.5;\n    this.transparencia = propiedades.transparencia || 0;\n    this.x = propiedades.x || 0;\n    this.y = propiedades.y || 0;\n    this.z = propiedades.z || 0;\n    this.espejado = propiedades.espejado;\n    this.espejado_vertical = propiedades.espejado_vertical;\n\n    this.sprite[\"actor\"] = this;\n\n    if (propiedades.es_texto) {\n      this.texto = propiedades.texto;\n      this.fuente = propiedades.fuente;\n\n      if (propiedades.fondo) {\n        this.fondo = propiedades.fondo;\n      }\n    }\n\n    this.sprite.update = () => {\n      this.ejecutar_de_modo_seguro(() => {\n        this.actualizar();\n      });\n    };\n\n    this.sprite.on(\"animationcomplete\", (anim, frame) => {\n      this.ejecutar_de_modo_seguro(() => {\n        if (frame.isLast) {\n          let nombre = anim.key.split(\"-\")[1];\n          // una vez que avisó que terminó la animación la repite.\n          this.sprite.anims.play(anim.key);\n          this.cuando_finaliza_animacion(nombre);\n          this.automata.cuando_finaliza_animacion(nombre);\n        }\n      });\n    });\n\n    this.sprite.on(\"pointerdown\", cursor => {\n      this.ejecutar_de_modo_seguro(() => {\n        let posicion = this.pilas.utilidades.convertir_coordenada_de_phaser_a_pilas(cursor.x, cursor.y);\n        this.cuando_hace_click(posicion.x, posicion.y, cursor);\n      });\n    });\n\n    this.sprite.on(\"pointerup\", cursor => {\n      this.ejecutar_de_modo_seguro(() => {\n        let posicion = this.pilas.utilidades.convertir_coordenada_de_phaser_a_pilas(cursor.x, cursor.y);\n        this.cuando_termina_de_hacer_click(posicion.x, posicion.y, cursor);\n      });\n    });\n\n    this.sprite.on(\"pointerout\", cursor => {\n      this.ejecutar_de_modo_seguro(() => {\n        let posicion = this.pilas.utilidades.convertir_coordenada_de_phaser_a_pilas(cursor.x, cursor.y);\n        this.cuando_sale(posicion.x, posicion.y, cursor);\n      });\n    });\n\n    this.sprite.on(\"pointermove\", cursor => {\n      this.ejecutar_de_modo_seguro(() => {\n        let posicion = this.pilas.utilidades.convertir_coordenada_de_phaser_a_pilas(cursor.x, cursor.y);\n        this.cuando_mueve(posicion.x, posicion.y, cursor);\n      });\n    });\n\n    this.pilas.escena.agregar_actor(this);\n  }\n\n  ejecutar_de_modo_seguro(funcion) {\n    try {\n      funcion();\n    } catch (e) {\n      this.pilas.mensajes.emitir_excepcion_al_editor(e, \"actualizar actor\");\n      this.pilas.modo.pausar();\n    }\n  }\n\n  private crear_sprite(tipo, imagen_inicial) {\n    let galeria = null;\n    let imagen = null;\n    let sprite = null;\n\n    this.pilas.utilidades.validar_que_existe_imagen(imagen_inicial);\n\n    // Como las imágenes pueden ser cadenas que representen cuadros\n    // dentro de un spritesheet (caso \"spritesheet:imagen\") o el nombre de una\n    // imagen normal (caso \"imagen\") se utiliza esta comprobación para\n    // distinguir cualquiera de estos casos.\n    if (imagen_inicial.indexOf(\":\") > -1) {\n      galeria = imagen_inicial.split(\":\")[0];\n      imagen = imagen_inicial.split(\":\")[1];\n    } else {\n      galeria = null;\n      imagen = imagen_inicial;\n    }\n\n    switch (tipo) {\n      case \"matter\":\n        if (galeria) {\n          sprite = this.pilas.modo.matter.add.sprite(0, 0, galeria, imagen);\n        } else {\n          sprite = this.pilas.modo.matter.add.sprite(0, 0, imagen);\n        }\n        break;\n\n      case \"sprite\":\n        if (galeria) {\n          sprite = this.pilas.modo.add.sprite(0, 0, galeria, imagen);\n        } else {\n          sprite = this.pilas.modo.add.sprite(0, 0, imagen);\n        }\n        break;\n\n      default:\n        throw Error(`No se puede crear un sprite de tipo ${tipo}`);\n    }\n\n    return sprite;\n  }\n\n  protected copiar_atributos_de_sprite(origen, destino) {\n    destino.x = origen.x;\n    destino.y = origen.y;\n    destino.angle = origen.angle;\n    destino.scaleX = origen.scaleX;\n    destino.scaleY = origen.scaleY;\n\n    destino.alpha = origen.alpha;\n    destino.flipX = origen.flipX;\n    destino.flipY = origen.flipY;\n    destino.depth = origen.depth;\n\n    destino.setOrigin(origen.originX, origen.originY);\n  }\n\n  iniciar() {}\n\n  get interactivo() {\n    return this.sprite.input.enabled;\n  }\n\n  set interactivo(activo: boolean) {\n    if (activo) {\n      this.sprite.setInteractive();\n    } else {\n      this.sprite.disableInteractive();\n    }\n  }\n\n  set area_de_interactividad(v: any) {\n    console.warn(\"No pude definir el area así, use definir_area_de_interactividad\");\n  }\n\n  definir_area_de_interactividad(ancho: number, alto: number) {\n    // TODO: usar hitArea.setSize cuando actualicemos phaser > 3.16.2\n    if (this.sprite) {\n      this.sprite.width = ancho;\n      this.sprite.height = alto;\n      this.sprite.input.hitArea.width = ancho;\n      this.sprite.input.hitArea.height = alto;\n      this.sprite.setOrigin(this.centro_x, this.centro_y);\n    } else {\n      console.log(\"aún no tiene sprite\");\n    }\n  }\n\n  cuando_hace_click_en_la_pantalla(x: number, y: number, evento_original: any) {}\n\n  get area_de_interactividad() {\n    let ancho = this.sprite.input.hitArea.width;\n    let alto = this.sprite.input.hitArea.height;\n\n    return { ancho, alto };\n  }\n\n  set fondo(fondo: string) {}\n\n  serializar() {\n    let texto = \"\";\n    let fondo = \"\";\n    let fuente = \"\";\n\n    if (this._es_texto) {\n      texto = this._texto.text;\n      fondo = this._fondo_imagen;\n      fuente = this._fuente;\n    }\n\n    let sensores_serializados = [];\n\n    if (this.sensores) {\n      sensores_serializados = this.sensores.map(e => {\n        return e.vertices.map(e => {\n          return {\n            x: e.x,\n            y: e.y,\n            isInternal: e.isInternal\n            //\n          };\n        });\n      });\n    }\n\n    return {\n      tipo: this.tipo,\n      x: Math.round(this.x),\n      y: Math.round(this.y),\n      z: Math.round(this.z),\n      centro_x: this.centro_x,\n      centro_y: this.centro_y,\n      rotacion: this.rotacion,\n      escala_x: this.escala_x,\n      escala_y: this.escala_y,\n      imagen: this.imagen,\n\n      figura: this.figura,\n      figura_ancho: this.figura_ancho,\n      figura_alto: this.figura_alto,\n      figura_radio: this.figura_radio,\n\n      figura_dinamica: this.dinamico,\n      figura_sensor: this.sensor,\n\n      fijo: this.fijo,\n\n      es_texto: this._es_texto,\n      texto: texto,\n      fondo: fondo,\n      fuente: fuente,\n      texto_con_borde: this._texto_con_borde,\n      color_de_texto: this._color_de_texto,\n\n      espejado: this.espejado,\n      espejado_vertical: this.espejado_vertical,\n      transparencia: this.transparencia,\n      id_color: this.id_color,\n\n      sensores: sensores_serializados\n    };\n  }\n\n  set etiqueta(etiqueta) {\n    this._etiqueta = etiqueta;\n  }\n\n  get etiqueta() {\n    return this._etiqueta;\n  }\n\n  tiene_etiqueta(etiqueta: string) {\n    return this.etiqueta === etiqueta;\n  }\n\n  generar_color_para_depurar() {\n    return this.pilas.utilidades.obtener_color_al_azar();\n  }\n\n  pre_actualizar() {\n    if (this.figura && this.sin_rotacion) {\n      (this.sprite as any).setAngularVelocity(0);\n    }\n\n    this.actualizar_comportamientos();\n    this.automata.actualizar();\n  }\n\n  actualizar_comportamientos() {\n    if (this._comportamiento_actual) {\n      let termina = this._comportamiento_actual.actualizar();\n\n      if (termina) {\n        if (this._comportamientos.length > 0) {\n          this._adoptar_siguiente_comportamiento();\n        } else {\n          this._comportamiento_actual = null;\n        }\n      }\n    } else {\n      if (this._comportamientos.length > 0) {\n        this._adoptar_siguiente_comportamiento();\n      }\n    }\n  }\n\n  private _adoptar_siguiente_comportamiento() {\n    let datos = this._comportamientos[0];\n    let nombre = datos.nombre_del_comportamiento;\n\n    let clase = this.pilas.comportamientos.buscar(nombre);\n\n    if (clase) {\n      let instancia = new clase(this.pilas, this);\n      instancia.iniciar(datos.argumentos);\n\n      // Nota: solo comienza a actualizar el comportamiento si no se limpió la lista\n      //       de comportamientos desde la función iniciar. Por ejemplo, si el usuario\n      //       en iniciar llama a \"hacer_inmediatamente\" o \"limpiar_comportamientos\" no se\n      //       tiene que seguir actualizando este comportamiento.\n      if (this._comportamientos.length > 0) {\n        this._comportamientos.shift();\n        this._comportamiento_actual = instancia;\n      }\n    }\n  }\n\n  hacer(nombre_del_comportamiento, argumentos: any = undefined) {\n    this.pilas.comportamientos.validar_si_existe(nombre_del_comportamiento);\n    this._comportamientos.push({ nombre_del_comportamiento, argumentos });\n  }\n\n  eliminar_comportamientos() {\n    this._comportamientos = [];\n    this._comportamiento_actual = null;\n  }\n\n  hacer_inmediatamente(nombre_del_comportamiento, argumentos: any = undefined) {\n    this.eliminar_comportamientos();\n    this.hacer(nombre_del_comportamiento, argumentos);\n  }\n\n  get estado() {\n    return this.automata.estado;\n  }\n\n  set estado(estado) {\n    this.automata.estado = estado;\n  }\n\n  actualizar() {}\n\n  actualizar_habilidades() {\n    this._habilidades.map(h => {\n      h.actualizar();\n    });\n  }\n\n  actualizar_sensores() {\n    let Body = this.pilas.Phaser.Physics.Matter.Matter.Body;\n    this.sensores.map(s => {\n      let { x, y } = this.pilas.utilidades.convertir_coordenada_de_pilas_a_phaser(this.x, this.y);\n\n      Body.setPosition(s, {\n        x: x + s.distancia_x,\n        y: y - s.distancia_y\n      });\n\n      Body.setVelocity(s, { x: 0, y: 0 });\n      Body.setAngularVelocity(s, 0);\n\n      // Descarta colisiones con actores que ya no están en la escena.\n      s.colisiones = s.colisiones.filter(a => a._vivo);\n    });\n  }\n\n  get imagen(): string {\n    if (this.sprite.frame.name === \"__BASE\") {\n      return this.sprite.texture.key;\n    } else {\n      return `${this.sprite.texture.key}:${this.sprite.frame.name}`;\n    }\n  }\n\n  get nombre() {\n    return this._nombre;\n  }\n\n  set nombre(a: any) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(a: any) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  set imagen(nombre: string) {\n    let galeria = null;\n    let imagen = null;\n\n    this.pilas.utilidades.validar_que_existe_imagen(nombre);\n\n    if (nombre.indexOf(\":\") > -1) {\n      galeria = nombre.split(\":\")[0];\n      imagen = nombre.split(\":\")[1];\n    } else {\n      galeria = null;\n      imagen = nombre;\n    }\n\n    if (galeria) {\n      this.sprite.setTexture(galeria, imagen);\n    } else {\n      this.sprite.setTexture(imagen);\n    }\n  }\n\n  set x(_x) {\n    if (this.pilas.utilidades.es_animacion(_x)) {\n      this.pilas.animar(this, \"x\", _x);\n    } else {\n      this.pilas.utilidades.validar_numero(_x);\n      let { x } = this.pilas.utilidades.convertir_coordenada_de_pilas_a_phaser(_x, 0);\n      this.sprite.x = x;\n    }\n  }\n\n  get x() {\n    let { x } = this.pilas.utilidades.convertir_coordenada_de_phaser_a_pilas(this.sprite.x, 0);\n    return x;\n  }\n\n  set y(_y: any) {\n    if (this.pilas.utilidades.es_animacion(_y)) {\n      this.pilas.animar(this, \"y\", _y);\n    } else {\n      this.pilas.utilidades.validar_numero(_y);\n      let { y } = this.pilas.utilidades.convertir_coordenada_de_pilas_a_phaser(0, _y);\n      this.sprite.y = y;\n    }\n  }\n\n  get y() {\n    let { y } = this.pilas.utilidades.convertir_coordenada_de_phaser_a_pilas(0, this.sprite.y);\n    return y;\n  }\n\n  set z(_z: number) {\n    this.pilas.utilidades.validar_numero(_z);\n    this.sprite.depth = -_z;\n  }\n\n  get z() {\n    return -this.sprite.depth;\n  }\n\n  set rotacion(angulo: any) {\n    if (this.pilas.utilidades.es_animacion(angulo)) {\n      this.pilas.animar(this, \"rotacion\", angulo);\n    } else {\n      this.pilas.utilidades.validar_numero(angulo);\n      this.sprite.angle = -(angulo % 360);\n    }\n  }\n\n  get rotacion() {\n    return -this.sprite.angle % 360;\n  }\n\n  set escala_x(s) {\n    if (this.pilas.utilidades.es_animacion(s)) {\n      this.pilas.animar(this, \"escala_x\", s);\n    } else {\n      this.pilas.utilidades.validar_numero(s);\n      this.sprite.scaleX = s;\n    }\n  }\n\n  get escala_x() {\n    return this.sprite.scaleX;\n  }\n\n  set escala_y(s) {\n    if (this.pilas.utilidades.es_animacion(s)) {\n      this.pilas.animar(this, \"escala_y\", s);\n    } else {\n      this.pilas.utilidades.validar_numero(s);\n      this.sprite.scaleY = s;\n    }\n  }\n\n  get escala_y() {\n    return this.sprite.scaleY;\n  }\n\n  get escala() {\n    return this.escala_x;\n  }\n\n  set escala(escala) {\n    if (this.pilas.utilidades.es_animacion(escala)) {\n      this.pilas.animar(this, \"escala\", escala);\n    } else {\n      this.pilas.utilidades.validar_numero(escala);\n      this.escala_x = escala;\n      this.escala_y = escala;\n    }\n  }\n\n  get centro_y() {\n    return this.sprite.originY;\n  }\n\n  set centro_y(y) {\n    let comunes = {\n      centro: 0.5,\n      arriba: 0,\n      abajo: 1,\n      medio: 0.5\n    };\n\n    if (comunes[y] !== undefined) {\n      y = comunes[y];\n    }\n\n    this.pilas.utilidades.validar_numero(y);\n    this.sprite.setOrigin(this.centro_x, y);\n  }\n\n  get centro_x() {\n    return this.sprite.originX;\n  }\n\n  set centro_x(x) {\n    let comunes = {\n      centro: 0.5,\n      izquierda: 0,\n      derecha: 1,\n      medio: 0.5\n    };\n\n    if (comunes[x] !== undefined) {\n      x = comunes[x];\n    }\n\n    this.pilas.utilidades.validar_numero(x);\n    this.sprite.setOrigin(x, this.centro_y);\n  }\n\n  set transparencia(t) {\n    if (this.pilas.utilidades.es_animacion(t)) {\n      this.pilas.animar(this, \"transparencia\", t);\n    } else {\n      this.pilas.utilidades.validar_numero(t);\n      t = this.pilas.utilidades.limitar(t, 0, 100);\n      this.sprite.alpha = 1 - t / 100;\n    }\n  }\n\n  get transparencia() {\n    return (1 - this.sprite.alpha) * 100;\n  }\n\n  toString() {\n    let clase = this.constructor[\"name\"];\n\n    if (this.esta_vivo()) {\n      let x = this.x.toFixed(2);\n      let y = this.y.toFixed(2);\n      return `<${clase} en (${x}, ${y})>`;\n    } else {\n      `<${clase} eliminado>`;\n    }\n  }\n\n  fallar_si_no_tiene_figura() {\n    if (!this.figura) {\n      throw Error(`Este actor no tiene figura física, no se puede llamar a este método`);\n    }\n  }\n\n  crear_figura_rectangular(ancho: number = 0, alto: number = 0) {\n    this.fallar_si_no_tiene_figura();\n\n    this.pilas.utilidades.validar_numero(ancho);\n    this.pilas.utilidades.validar_numero(alto);\n\n    (this.sprite as any).setRectangle(ancho, alto);\n    //(this.sprite as any).setFriction(0, 0, 0);\n  }\n\n  crear_figura_circular(radio: number = 0) {\n    this.fallar_si_no_tiene_figura();\n\n    this.pilas.utilidades.validar_numero(radio);\n\n    if (radio < 1) {\n      radio = 30;\n    }\n\n    (this.sprite as any).setCircle(radio);\n    //(this.sprite as any).setFriction(0, 0, 0);\n  }\n\n  get ancho() {\n    return this.sprite.width;\n  }\n\n  get alto() {\n    return this.sprite.height;\n  }\n\n  set alto(a: number) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  set ancho(a: number) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  get estatico() {\n    if ((this.sprite as any).isStatic !== undefined) {\n      return (this.sprite as any).isStatic();\n    }\n\n    return false;\n  }\n\n  set estatico(estatico: boolean) {\n    if ((this.sprite as any).setStatic !== undefined) {\n      (this.sprite as any).setStatic(estatico);\n      (this.sprite as any).setVelocity(0, 0);\n    } else {\n      console.warn(\"Este actor no tiene figura, ignorando valor estatico/dinámico.\");\n    }\n  }\n\n  set dinamico(dinamico: boolean) {\n    this.estatico = !dinamico;\n  }\n\n  get dinamico() {\n    return !this.estatico;\n  }\n\n  impulsar(x, y) {\n    this.fallar_si_no_tiene_figura();\n    (this.sprite as any).setVelocity(x, -y);\n  }\n\n  get velocidad_x() {\n    this.fallar_si_no_tiene_figura();\n    return (this.sprite.body as any).velocity.x;\n  }\n\n  set velocidad_x(valor: number) {\n    this.fallar_si_no_tiene_figura();\n    (this.sprite as any).setVelocityX(valor);\n  }\n\n  get velocidad_y() {\n    this.fallar_si_no_tiene_figura();\n    return -(this.sprite.body as any).velocity.y;\n  }\n\n  set velocidad_y(valor: number) {\n    this.fallar_si_no_tiene_figura();\n    (this.sprite as any).setVelocityY(-valor);\n  }\n\n  set rebote(valor: number) {\n    this.pilas.utilidades.validar_numero(valor);\n    this.fallar_si_no_tiene_figura();\n    (this.sprite as any).setBounce(valor);\n  }\n\n  get rebote() {\n    this.fallar_si_no_tiene_figura();\n    return (this.sprite.body as any).restitution;\n  }\n\n  set sensor(valor: boolean) {\n    this.fallar_si_no_tiene_figura();\n    (this.sprite as any).setSensor(valor);\n  }\n\n  get sensor() {\n    if ((this.sprite as any).body && (this.sprite.body as any).isSensor !== undefined) {\n      return (this.sprite as any).isSensor();\n    }\n\n    return false;\n  }\n\n  get fijo() {\n    return this.sprite.scrollFactorX == 0;\n  }\n\n  set fijo(valor: boolean) {\n    if (valor) {\n      this.sprite.setScrollFactor(0, 0);\n\n      if (this._texto) {\n        this._texto.setScrollFactor(0, 0);\n      }\n    } else {\n      this.sprite.setScrollFactor(1, 1);\n\n      if (this._texto) {\n        this._texto.setScrollFactor(1, 1);\n      }\n    }\n  }\n\n  set espejado(valor: boolean) {\n    this.sprite.setFlipX(valor);\n  }\n\n  get espejado() {\n    return this.sprite.flipX;\n  }\n\n  set espejado_vertical(valor: boolean) {\n    this.sprite.setFlipY(valor);\n  }\n\n  get espejado_vertical() {\n    return this.sprite.flipY;\n  }\n\n  cada_segundo(segundos_transcurridos: number) {}\n\n  avanzar(rotacion: number = null, velocidad: number = 1) {\n    if (rotacion === null) {\n      rotacion = this.rotacion;\n    }\n\n    let r = this.pilas.utilidades.convertir_angulo_a_radianes(rotacion);\n\n    this.x += Math.cos(r) * velocidad;\n    this.y += Math.sin(r) * velocidad;\n  }\n\n  crear_animacion(nombre, cuadros, velocidad) {\n    this.pilas.animaciones.crear_animacion(nombre, cuadros, velocidad);\n  }\n\n  reproducir_animacion(nombre_de_la_animacion) {\n    this.sprite.anims.play(nombre_de_la_animacion);\n  }\n\n  cuando_finaliza_animacion(animacion: string) {}\n\n  set animacion(nombre) {\n    if (this._animacion_en_curso !== nombre) {\n      if (this.pilas.animaciones.existe_animacion(nombre)) {\n        this.reproducir_animacion(nombre);\n        this._animacion_en_curso = nombre;\n      } else {\n        throw Error(`No se ha creado la animación '${nombre}' previamente`);\n      }\n    }\n  }\n\n  get animacion() {\n    return this._animacion_en_curso;\n  }\n\n  cuando_comienza_una_colision(actor: Actor) {}\n\n  cuando_se_mantiene_una_colision(actor: Actor) {}\n\n  cuando_termina_una_colision(actor: Actor) {}\n\n  /**\n   * Se llama en todo momento en que se produce una colisión.\n   */\n  cuando_colisiona(actor: Actor) {}\n\n  cuando_hace_click(x, y, evento_original) {}\n\n  cuando_termina_de_hacer_click(x, y, evento_original) {}\n\n  cuando_sale(x, y, evento_original) {}\n\n  cuando_mueve(x, y, evento_original) {}\n\n  cuando_pulsa_tecla(tecla: string, evento_original: any) {}\n\n  cuando_suelta_tecla(tecla: string, evento_original: any) {}\n\n  get cantidad_de_colisiones() {\n    return this.colisiones.length;\n  }\n\n  agregar_sensores_desde_lista(lista_de_sensores) {\n    lista_de_sensores.map(sensor => {\n      this.agregar_sensor(sensor.ancho, sensor.alto, sensor.x, sensor.y, sensor.nombre);\n    });\n  }\n\n  agregar_sensor(ancho, alto, x, y, nombre = \"sin nombre\") {\n    let pos = this.pilas.utilidades.convertir_coordenada_de_pilas_a_phaser(x, y);\n\n    let figura = this.pilas.modo.matter.add.rectangle(pos.x, pos.y, ancho, alto, {\n      isSensor: true,\n      isStatic: false\n    });\n\n    figura.distancia_x = x;\n    figura.distancia_y = y;\n\n    figura[\"es_sensor\"] = true;\n    figura[\"es_dinamica\"] = true;\n\n    figura.sensor_del_actor = this;\n    figura.colisiones = [];\n    figura[\"nombre\"] = nombre;\n\n    this.sensores.push(figura);\n    return figura;\n  }\n\n  eliminar() {\n    this._vivo = false;\n  }\n\n  esta_vivo() {\n    return this._vivo;\n  }\n\n  get fuente() {\n    return \"\";\n  }\n\n  set fuente(fuente: string) {}\n\n  set figura_ancho(valor: number) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  get figura_ancho() {\n    return this._figura_ancho;\n  }\n\n  set figura_alto(valor: number) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  get figura_alto() {\n    return this._figura_alto;\n  }\n\n  set figura_radio(valor: number) {\n    throw new Error(\"No puede definir este atributo\");\n  }\n\n  get figura_radio() {\n    return this._figura_radio;\n  }\n\n  /**\n   * Muestra un mensaje como si se tratara de un globo de historieta. Llamar\n   * a este método borra el dialogo anterior si existiera.\n   */\n  decir(mensaje: string, duracion: number = 4) {\n    if (this._dialogo) {\n      this._dialogo.eliminar();\n      this._dialogo = null;\n    }\n\n    let texto = this.pilas.actores.texto();\n    texto.texto = mensaje;\n    texto.x = this.x - 15;\n    texto.y = this.y + this.alto;\n    texto.fuente = \"color-negro\";\n    texto.transparencia = 100;\n    texto.transparencia = [0];\n    texto.fondo = \"imagenes:redimensionables/dialogo\";\n    texto.color = \"black\";\n    texto.centro_x = 1;\n    texto.centro_y = 1;\n    texto.z = this.z - 1;\n\n    texto.texto = mensaje;\n    mantener_en_pantalla();\n\n    function mantener_en_pantalla() {\n      // Evita que salga por el borde izquierdo.\n      if (texto.x - texto.sprite.width < texto.pilas.camara.borde_izquierdo) {\n        texto.x = texto.pilas.camara.borde_izquierdo + texto.sprite.width;\n      }\n\n      // Evita que salga por el borde derecho.\n      if (texto.x + 20 > texto.pilas.camara.borde_derecho) {\n        texto.x = texto.pilas.camara.borde_derecho - 20;\n      }\n\n      // Evita que salga por el borde de arriba.\n      if (texto.y + texto.sprite.height > texto.pilas.camara.borde_arriba) {\n        texto.y = texto.pilas.camara.borde_arriba - texto.sprite.height;\n      }\n\n      // Evita que salga por el borde de abajo.\n      if (texto.y - 15 < texto.pilas.camara.borde_abajo) {\n        texto.y = texto.pilas.camara.borde_abajo + 15;\n      }\n    }\n\n    texto.actualizar = () => {\n      if (this.esta_vivo()) {\n        texto.x = this.x - 15;\n        texto.y = this.y + this.alto;\n        mantener_en_pantalla();\n      }\n    };\n\n    this._dialogo = texto;\n\n    this.pilas.luego(duracion, () => {\n      if (texto.esta_vivo()) {\n        texto.eliminar();\n\n        if (texto === this._dialogo) {\n          this._dialogo = null;\n        }\n      }\n    });\n  }\n\n  aprender(habilidad: string) {\n    let clase = this.pilas.habilidades.buscar(habilidad);\n\n    if (clase) {\n      if (this.tiene_habilidad(clase.name)) {\n        console.warn(`No se aplica la habilidad ${clase.name} porque el actor ya la tenía vinculada.`);\n      } else {\n        let instancia = new clase(this.pilas, this);\n        instancia.iniciar();\n        this._habilidades.push(instancia);\n      }\n    }\n  }\n\n  olvidar(habilidad: string) {\n    let clase = this.pilas.habilidades.buscar(habilidad);\n\n    if (clase) {\n      if (!this.tiene_habilidad(clase.name)) {\n        console.warn(`No se puede olvidar la habilidad '${clase.name}' porque el actor no la tiene.`);\n      } else {\n        let indice = this._habilidades.findIndex(e => e.constructor.name == clase.name);\n        let habilidad_a_eliminar = this._habilidades[indice];\n        habilidad_a_eliminar.eliminar();\n        this._habilidades.splice(indice, 1);\n      }\n    }\n  }\n\n  tiene_habilidad(habilidad: string) {\n    return (\n      this._habilidades.filter(h => {\n        return h.constructor.name === habilidad;\n      }).length > 0\n    );\n  }\n\n  aumentar(cantidad: number = 1) {}\n\n  set con_borde(con_borde: boolean) {\n    // ver ActorTextoBase.con_borde\n    this._texto_con_borde = con_borde;\n  }\n\n  set color(color: string) {\n    // ver ActorTextoBase.color\n    this._color_de_texto = color;\n  }\n\n  get control() {\n    return this.pilas.control;\n  }\n\n  /**\n   * Retorna la distancia en pixels entre este actor y otro punto\n   * de la pantalla.\n   */\n  obtener_distancia_al_punto(x: number, y: number) {\n    return this.pilas.utilidades.obtener_distancia_entre(this.x, this.y, x, y);\n  }\n\n  /**\n   * Retorna la distancia en pixels de este actor a otro.\n   */\n  obtener_distancia_al_actor(actor: Actor) {\n    return this.obtener_distancia_al_punto(actor.x, actor.y);\n  }\n\n  /**\n   * Mueve el personaje en la dirección indicada.\n   */\n  mover_hacia_el_punto(x: number, y: number, velocidad: number = 10) {\n    let angulo = this.pilas.obtener_angulo_entre_puntos(this.x, this.y, x, y);\n    this.avanzar(angulo, velocidad);\n  }\n\n  enviar_mensaje(mensaje: string, datos: any = {}) {\n    this.cuando_llega_un_mensaje(mensaje, datos);\n\n    // Intenta llamar a un método específico para este mensaje.\n    if (this[`cuando_llega_el_mensaje_${mensaje}`]) {\n      this[`cuando_llega_el_mensaje_${mensaje}`](datos);\n    }\n  }\n\n  cuando_llega_un_mensaje(mensaje: string, datos: any = {}) {}\n\n  /**\n   * Envía un mensaje a todos los actores y la escena actual.\n   *\n   * Para capturar estos mensajes desde actores o la escena, se tiene\n   * que crear un método de la forma \"cuando_llega_el_mensaje_nombre\" donde\n   * \"nombre\" tiene que ser mensaje que se quiere capturar.\n   *\n   * Por ejemplo, si un actor llama al código \"this.enviar_mensaje_global('ganar')\"\n   * deberías poder capturar ese mensaje desde cualquier actor o escena\n   * declarando el método \"cuando_llega_el_mensaje_ganar\".\n   */\n  enviar_mensaje_global(mensaje: string, datos: any = {}) {\n    this.pilas.enviar_mensaje_global(mensaje, datos);\n  }\n\n  get camara() {\n    return this.pilas.camara;\n  }\n\n  hacer_recorrido(posiciones, duracion = 1, veces = 1, seguir_rotacion = false) {\n    this.pilas.utilidades.validar_parametro_lista_de_numeros_pares(\"posiciones\", posiciones);\n    this.pilas.utilidades.validar_parametro_numero_positivo(\"duracion\", duracion);\n    this.pilas.utilidades.validar_parametro_numero_entero_cero_o_positivo(\"veces\", veces);\n\n    let puntos_a_recorrer = [this.x, this.y].concat(posiciones);\n    let curve = new Phaser.Curves.Spline(puntos_a_recorrer);\n\n    let anterior_x = this.x;\n    let anterior_y = this.y;\n\n    this.pilas.modo.tweens.add({\n      targets: { t: 0 },\n      t: 1,\n      ease: \"Linear\",\n      duration: duracion * 1000,\n      yoyo: false,\n      repeat: veces - 1,\n      onUpdate: (tween, target) => {\n        let { x, y } = curve.getPoint(target.t);\n        if (this.esta_vivo()) {\n          this.x = x;\n          this.y = y;\n\n          if (seguir_rotacion) {\n            let dx = this.x - anterior_x;\n            let dy = this.y - anterior_y;\n            this.rotacion = this.pilas.utilidades.convertir_radianes_a_angulos(Math.atan2(dy, dx));\n          }\n\n          anterior_x = x;\n          anterior_y = y;\n        }\n      }\n    });\n  }\n\n  obtener_sensor(nombre: string) {\n    let figura = this.sensores.find(e => e.nombre === nombre);\n\n    if (!figura) {\n      let nombres_de_sensores = this.sensores.map(s => s.nombre);\n\n      if (nombres_de_sensores.length > 0) {\n        let sugerencia = this.pilas.utilidades.obtener_mas_similar(nombre, nombres_de_sensores);\n        throw Error(`No existe un sensor que se llame \"${nombre}\". ¿Quisiste decir \"${sugerencia}\"?`);\n      } else {\n        throw Error(`No hay sensores creados, así que no se buscó si existía uno llamado \"${nombre}\".`);\n      }\n    }\n\n    if (figura) {\n      return new Sensor(figura);\n    }\n  }\n\n  reproducir_sonido(nombre: string) {\n    return this.pilas.reproducir_sonido(nombre);\n  }\n}\n",
      "archivo": "-actor-base.ts"
    },
    {
      "nombre": "-actor-texto-base",
      "codigo": "class ActorTextoBase extends ActorBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/invisible\",\n    texto: \"Hola mundo\",\n    es_texto: true,\n    fuente: \"color-blanco-con-sombra-grande\"\n  };\n\n  margen_interno: number = 30;\n\n  iniciar() {}\n\n  pre_actualizar() {\n    super.pre_actualizar();\n\n    this.copiar_atributos_de_sprite(this.sprite, this._texto);\n\n    if (this._fondo) {\n      this.copiar_atributos_de_sprite(this.sprite, this._fondo);\n      this._texto.depth = this._texto.depth + 1;\n      this._fondo.x += this.margen_interno * this.sprite.originX - this.margen_interno * 0.5;\n      this._fondo.y += this.margen_interno * this.sprite.originY - this.margen_interno * 0.5;\n\n      // el dialogo es un tipo de fondo especial, que queda mal\n      // si el texto está muy arriba.\n      if (this._fondo_imagen.includes(\"dialogo\")) {\n        this._fondo.y += 4;\n      }\n\n      if (this.fijo) {\n        this._fondo.setScrollFactor(0, 0);\n      } else {\n        this._fondo.setScrollFactor(1, 1);\n      }\n    }\n  }\n\n  actualizar() {}\n\n  set texto(texto: string) {\n    if (!this._texto) {\n      this._texto = this.pilas.modo.add.bitmapText(0, 0, this._fuente, texto);\n    } else {\n      this._texto.text = texto;\n    }\n\n    this.actualizar_tamano_del_fondo();\n  }\n\n  get fuente() {\n    return this._fuente;\n  }\n\n  set fuente(fuente: string) {\n    let texto = this.texto;\n    if (this._texto) {\n      this._texto.destroy();\n    }\n\n    this._texto = this.pilas.modo.add.bitmapText(0, 0, fuente, texto);\n    this._fuente = fuente;\n    this.actualizar_tamano_del_fondo();\n  }\n\n  get texto() {\n    return this._texto.text;\n  }\n\n  set fondo(fondo: string) {\n    this._fondo_imagen = fondo;\n\n    if (!this._fondo) {\n      this.crear_fondo(fondo);\n    } else {\n      this._fondo.destroy();\n      this.crear_fondo(fondo);\n    }\n  }\n\n  private crear_fondo(fondo) {\n    let imagen = null;\n\n    if (fondo.indexOf(\":\") > -1) {\n      let partes = fondo.split(\":\");\n      imagen = { key: partes[0], frame: partes[1] };\n    } else {\n      imagen = fondo;\n    }\n\n    this._fondo = this.pilas.modo.add[\"nineslice\"](0, 0, 30, 20, imagen, 10, 10);\n    this.pre_actualizar();\n    this.actualizar_tamano_del_fondo();\n  }\n\n  private actualizar_tamano_del_fondo() {\n    this.definir_area_de_interactividad(this._texto.width, this._texto.height);\n\n    if (!this._fondo) {\n      return;\n    }\n\n    let ancho = this._texto.width + this.margen_interno;\n    let alto = this._texto.height + this.margen_interno;\n\n    this._fondo.resize(ancho, alto);\n    this.definir_area_de_interactividad(ancho, alto);\n  }\n\n  eliminar() {\n    super.eliminar();\n  }\n}\n",
      "archivo": "-actor-texto-base.ts"
    },
    {
      "nombre": "-actor",
      "codigo": "class Actor extends ActorBase {\n  propiedades = {};\n\n  iniciar() {}\n\n  actualizar() {}\n}\n",
      "archivo": "-actor.ts"
    },
    {
      "nombre": "-pizarra-base",
      "codigo": "class PizarraBase extends Actor {\n  propiedades = {\n    imagen: \"imagenes:basicos/sin_imagen\"\n  };\n\n  _canvas: any;\n\n  iniciar() {\n    this._canvas = this.pilas.modo.add.graphics();\n  }\n\n  dibujar_circulo(x: number = 0, y: number = 0, radio: number = 20, color: any = \"negro\") {\n    let colorHexa = this.pilas.colores.convertir_a_hexa(color);\n\n    this._canvas.fillStyle(colorHexa, 1);\n    this._canvas.fillCircle(x, -y, radio);\n  }\n\n  dibujar_borde_de_circulo(x: number = 0, y: number = 0, radio: number = 20, color: any = \"negro\", grosor: number = 1) {\n    let colorHexa = this.pilas.colores.convertir_a_hexa(color);\n\n    this._canvas.lineStyle(grosor, colorHexa, 1);\n    this._canvas.strokeCircle(x, -y, radio);\n  }\n\n  dibujar_rectangulo(x: number = 0, y: number = 0, ancho: number = 20, alto: number = 20, color: any = \"negro\") {\n    let colorHexa = this.pilas.colores.convertir_a_hexa(color);\n\n    this._canvas.fillStyle(colorHexa, 1);\n    this._canvas.fillRect(x, -y, ancho, alto);\n  }\n\n  dibujar_borde_de_rectangulo(x: number = 0, y: number = 0, ancho: number = 20, alto: number = 20, color: any = \"negro\", grosor: number = 1) {\n    let colorHexa = this.pilas.colores.convertir_a_hexa(color);\n\n    this._canvas.lineStyle(grosor, colorHexa, 1);\n    this._canvas.strokeRect(x, -y, ancho, alto);\n  }\n\n  dibujar_linea(x: number = 0, y: number = 0, x1: number = 100, y1: number = 100, color: any = \"negro\", grosor: number = 1) {\n    let colorHexa = this.pilas.colores.convertir_a_hexa(color);\n\n    this._canvas.lineStyle(grosor, colorHexa, 1);\n    this._canvas.lineBetween(x, -y, x1, -y1);\n  }\n\n  limpiar() {\n    this._canvas.clear();\n  }\n\n  actualizar() {}\n\n  pre_actualizar() {\n    this.pilas.utilidades.sincronizar_contenedor(this._canvas, this.sprite);\n  }\n}\n",
      "archivo": "-pizarra-base.ts"
    },
    {
      "nombre": "aceituna",
      "codigo": "class aceituna extends Actor {\n  propiedades = {\n    imagen: \"imagenes:objetos/aceituna\"\n  };\n\n  iniciar() {\n    this.imagen = \"imagenes:objetos/aceituna\";\n  }\n}\n",
      "archivo": "aceituna.ts"
    },
    {
      "nombre": "actor",
      "codigo": "class actor extends Actor {\n  propiedades = {\n    imagen: \"imagenes:basicos/sin_imagen\"\n  };\n\n  iniciar() {}\n\n  actualizar() {}\n}\n",
      "archivo": "actor.ts"
    },
    {
      "nombre": "barra_de_energia",
      "codigo": "// @ts-ignore\nclass barra_de_energia extends PizarraBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/barra_de_energia\"\n  };\n\n  barra_largo: number = 200;\n  barra_alto: number = 15;\n  vida_actual: number = 100; // valor entre 0 y 100\n\n  private vida_anterior: number = 0;\n\n  iniciar() {\n    super.iniciar();\n    this.imagen = \"imagenes:basicos/invisible\";\n  }\n\n  actualizar() {\n    this.dibujar();\n    //this.vida_actual -= 0.2;\n  }\n\n  dibujar() {\n    if (this.vida_actual === this.vida_anterior) {\n      return;\n    }\n\n    this.vida_actual = Math.max(0, this.vida_actual);\n    this.vida_actual = Math.min(100, this.vida_actual);\n    this.vida_anterior = this.vida_actual;\n    this.dibujar_barra();\n  }\n\n  private dibujar_barra() {\n    let vida = this.vida_actual;\n    let largo = this.barra_largo;\n    let alto = this.barra_alto;\n    let x = -largo / 2;\n    let y = +alto / 2;\n\n    this.limpiar();\n    this.dibujar_borde_de_rectangulo(x, y, largo, alto, \"blanco\", 4);\n    this.dibujar_rectangulo(x, y, largo, alto, \"rojo\");\n\n    this.dibujar_rectangulo(x, y, (largo / 100) * vida, alto, \"amarillo\");\n  }\n}\n",
      "archivo": "barra_de_energia.ts"
    },
    {
      "nombre": "boton",
      "codigo": "class boton extends ActorTextoBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/invisible\",\n    fondo: \"imagenes:redimensionables/gris\",\n    texto: \"Botón\",\n    es_texto: true,\n    z: -10,\n    color: \"black\",\n    fuente: \"color-negro\"\n  };\n\n  cuando_hace_click() {\n    this.decir(\"¡has hecho click!\");\n    this.realizar_animacion_de_pulsacion();\n  }\n\n  realizar_animacion_de_pulsacion() {\n    this.y -= 2;\n\n    this.pilas.luego(0.2, () => {\n      this.y += 2;\n    });\n  }\n\n  cuando_mueve() {\n    this.pilas.definir_cursor(\"pointer\");\n  }\n\n  cuando_sale() {\n    this.pilas.definir_cursor(\"normal\");\n  }\n}\n",
      "archivo": "boton.ts"
    },
    {
      "nombre": "boton_activable",
      "codigo": "class boton_activable extends ActorTextoBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/invisible\",\n    fondo: \"imagenes:redimensionables/gris\",\n    texto: \"Botón\",\n    es_texto: true,\n    z: -10,\n    color: \"black\",\n    fuente: \"color-negro\"\n  };\n\n  habilitado: boolean = true;\n\n  cuando_hace_click() {\n    if (this.habilitado) {\n      this.decir(\"¡has hecho click!\");\n      this.realizar_animacion_de_pulsacion();\n    }\n  }\n\n  realizar_animacion_de_pulsacion() {\n    this.y -= 2;\n\n    this.pilas.luego(0.2, () => {\n      this.y += 2;\n    });\n  }\n\n  cuando_mueve() {\n    if (this.habilitado) {\n      this.pilas.definir_cursor(\"pointer\");\n    }\n  }\n\n  cuando_sale() {\n    if (this.habilitado) {\n      this.pilas.definir_cursor(\"normal\");\n    }\n  }\n\n  habilitar() {\n    this.habilitado = true;\n    this.transparencia = 0;\n  }\n\n  deshabilitar() {\n    this.habilitado = false;\n    this.transparencia = 30;\n    this.pilas.definir_cursor(\"normal\");\n  }\n\n  activar() {\n    this.habilitar();\n  }\n\n  desactivar() {\n    this.deshabilitar();\n  }\n}\n",
      "archivo": "boton_activable.ts"
    },
    {
      "nombre": "boton_de_control_abajo",
      "codigo": "class boton_de_control_abajo extends Actor {\n  propiedades = {\n    imagen: \"imagenes:botones/botones_abajo\",\n    z: -100\n  };\n\n  pulsado: boolean = false;\n\n  iniciar() {}\n\n  actualizar() {\n    if (this.pulsado) {\n      this.transparencia = 0;\n    } else {\n      this.transparencia = 50;\n    }\n\n    this.pilas.control.simular_pulsacion(\"abajo\", this.pulsado);\n  }\n\n  cuando_hace_click() {\n    this.pulsado = true;\n  }\n\n  cuando_sale() {\n    this.pulsado = false;\n  }\n\n  cuando_termina_de_hacer_click() {\n    this.pulsado = false;\n  }\n}\n",
      "archivo": "boton_de_control_abajo.ts"
    },
    {
      "nombre": "boton_de_control_arriba",
      "codigo": "class boton_de_control_arriba extends Actor {\n  propiedades = {\n    imagen: \"imagenes:botones/botones_arriba\",\n    z: -100\n  };\n\n  pulsado: boolean = false;\n\n  iniciar() {}\n\n  actualizar() {\n    if (this.pulsado) {\n      this.transparencia = 0;\n    } else {\n      this.transparencia = 50;\n    }\n\n    this.pilas.control.simular_pulsacion(\"arriba\", this.pulsado);\n  }\n\n  cuando_hace_click() {\n    this.pulsado = true;\n  }\n\n  cuando_sale() {\n    this.pulsado = false;\n  }\n\n  cuando_termina_de_hacer_click() {\n    this.pulsado = false;\n  }\n}\n",
      "archivo": "boton_de_control_arriba.ts"
    },
    {
      "nombre": "boton_de_control_derecha",
      "codigo": "class boton_de_control_derecha extends Actor {\n  propiedades = {\n    imagen: \"imagenes:botones/botones_derecha\",\n    z: -100\n  };\n\n  pulsado: boolean = false;\n\n  iniciar() {}\n\n  actualizar() {\n    if (this.pulsado) {\n      this.transparencia = 0;\n    } else {\n      this.transparencia = 50;\n    }\n\n    this.pilas.control.simular_pulsacion(\"derecha\", this.pulsado);\n  }\n\n  cuando_hace_click() {\n    this.pulsado = true;\n  }\n\n  cuando_sale() {\n    this.pulsado = false;\n  }\n\n  cuando_termina_de_hacer_click() {\n    this.pulsado = false;\n  }\n}\n",
      "archivo": "boton_de_control_derecha.ts"
    },
    {
      "nombre": "boton_de_control_espacio",
      "codigo": "class boton_de_control_espacio extends Actor {\n  propiedades = {\n    imagen: \"imagenes:botones/botones_a\",\n    z: -100\n  };\n\n  pulsado: boolean = false;\n\n  iniciar() {}\n\n  actualizar() {\n    if (this.pulsado) {\n      this.transparencia = 0;\n    } else {\n      this.transparencia = 50;\n    }\n\n    this.pilas.control.simular_pulsacion(\"espacio\", this.pulsado);\n  }\n\n  cuando_hace_click() {\n    this.pulsado = true;\n  }\n\n  cuando_sale() {\n    this.pulsado = false;\n  }\n\n  cuando_termina_de_hacer_click() {\n    this.pulsado = false;\n  }\n}\n",
      "archivo": "boton_de_control_espacio.ts"
    },
    {
      "nombre": "boton_de_control_izquierda",
      "codigo": "class boton_de_control_izquierda extends Actor {\n  propiedades = {\n    imagen: \"imagenes:botones/botones_izquierda\",\n    z: -100\n  };\n\n  pulsado: boolean = false;\n\n  iniciar() {}\n\n  actualizar() {\n    if (this.pulsado) {\n      this.transparencia = 0;\n    } else {\n      this.transparencia = 50;\n    }\n\n    this.pilas.control.simular_pulsacion(\"izquierda\", this.pulsado);\n  }\n\n  cuando_hace_click() {\n    this.pulsado = true;\n  }\n\n  cuando_sale() {\n    this.pulsado = false;\n  }\n\n  cuando_termina_de_hacer_click() {\n    this.pulsado = false;\n  }\n}\n",
      "archivo": "boton_de_control_izquierda.ts"
    },
    {
      "nombre": "caja",
      "codigo": "class caja extends Actor {\n  propiedades = {\n    x: 0,\n    y: 0,\n    imagen: \"imagenes:objetos/caja\",\n    etiqueta: \"caja\",\n    figura: \"rectangulo\",\n    figura_ancho: 45,\n    figura_alto: 45,\n    figura_rebote: 0.9\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "caja.ts"
    },
    {
      "nombre": "chispa",
      "codigo": "class chispa extends Actor {\n  propiedades = {\n    figura: \"\",\n    imagen: \"imagenes:efectos/chispa-3\",\n    etiqueta: \"chispa\"\n  };\n\n  iniciar() {\n    this.animacion = \"chispa\";\n  }\n\n  actualizar() {}\n\n  cuando_finaliza_animacion(nombre: string) {\n    this.eliminar();\n  }\n}\n",
      "archivo": "chispa.ts"
    },
    {
      "nombre": "conejo",
      "codigo": "class conejo extends Actor {\n  propiedades = {\n    x: 0,\n    y: 0,\n    imagen: \"imagenes:conejo/conejo_parado1\",\n\n    figura: \"rectangulo\",\n    figura_ancho: 50,\n    figura_alto: 100,\n    figura_radio: 50,\n    figura_sin_rotacion: true,\n    figura_dinamica: true,\n    figura_rebote: 0,\n    sensores: [\n      {\n        x: 0,\n        y: -51,\n        ancho: 64,\n        alto: 10,\n        nombre: \"pies\"\n      }\n    ]\n  };\n\n  toca_el_suelo = false;\n  pies = null;\n\n  iniciar() {\n    this.estado = \"parado\";\n    this.pies = this.obtener_sensor(\"pies\");\n  }\n\n  actualizar() {\n    if (this.pies.colisiones.length > 0) {\n      this.toca_el_suelo = true;\n    } else {\n      this.toca_el_suelo = false;\n    }\n  }\n\n  parado_iniciar() {\n    this.reproducir_animacion(\"conejo_parado\");\n  }\n\n  parado_actualizar() {\n    if (this.pilas.control.izquierda || this.pilas.control.derecha) {\n      this.estado = \"camina\";\n    }\n\n    if (this.pilas.control.arriba && this.toca_el_suelo) {\n      this.impulsar(0, 10);\n      this.estado = \"salta\";\n    }\n\n    if (!this.toca_el_suelo) {\n      this.estado = \"salta\";\n    }\n  }\n\n  camina_iniciar() {\n    this.reproducir_animacion(\"conejo_camina\");\n  }\n\n  camina_actualizar() {\n    if (this.pilas.control.izquierda) {\n      this.x -= 5;\n      this.espejado = true;\n    }\n\n    if (this.pilas.control.derecha) {\n      this.x += 5;\n      this.espejado = false;\n    }\n\n    if (!this.pilas.control.derecha && !this.pilas.control.izquierda) {\n      this.estado = \"parado\";\n      return;\n    }\n\n    if (this.pilas.control.arriba && this.toca_el_suelo) {\n      this.impulsar(0, 10);\n      this.estado = \"salta\";\n    }\n\n    if (!this.toca_el_suelo) {\n      this.estado = \"salta\";\n    }\n  }\n\n  salta_iniciar() {\n    this.reproducir_animacion(\"conejo_salta\");\n  }\n\n  salta_actualizar() {\n    if (this.pilas.control.izquierda) {\n      this.x -= 5;\n    }\n\n    if (this.pilas.control.derecha) {\n      this.x += 5;\n    }\n\n    if (this.toca_el_suelo) {\n      this.estado = \"parado\";\n    }\n  }\n\n  cuando_comienza_una_colision(actor) {\n    if (actor.etiqueta === \"moneda\") {\n      this.pilas.reproducir_sonido(\"moneda\");\n      actor.eliminar();\n    }\n\n    if (actor.etiqueta === \"plataforma\") {\n      if (this.velocidad_y > 0.1) {\n        return true;\n      }\n    }\n  }\n\n  cuando_se_mantiene_una_colision(actor) {}\n\n  cuando_termina_una_colision(actor) {}\n}\n",
      "archivo": "conejo.ts"
    },
    {
      "nombre": "deslizador",
      "codigo": "class deslizador extends Actor {\n  propiedades = {\n    x: 0,\n    y: 0,\n    imagen: \"imagenes:interfaz/interfaz_linea\",\n    etiqueta: \"deslizador\",\n    figura: \"\"\n  };\n\n  valor: number = 0;\n  marca: Actor;\n  esta_arrastrando_el_deslizador;\n\n  iniciar() {\n    this.imagen = \"imagenes:interfaz/interfaz_linea\";\n    this.esta_arrastrando_el_deslizador = false;\n    this.crear_marca();\n    this.conectar_eventos();\n  }\n\n  conectar_eventos() {\n    this.pilas.eventos.conectar(\"mueve_mouse\", datos => {\n      this.cuando_mueve_el_mouse(datos);\n    });\n\n    this.pilas.eventos.conectar(\"termina_click\", () => {\n      this.cuando_termina_de_hacer_click();\n    });\n  }\n\n  crear_marca() {\n    this.marca = this.pilas.actores.actor();\n    this.marca.imagen = \"imagenes:interfaz/interfaz_deslizador\";\n\n    // Hacer que la marca del deslizador ignore clicks.\n    this.marca.interactivo = false;\n  }\n\n  cuando_hace_click(x, y) {\n    this.esta_arrastrando_el_deslizador = true;\n    this.ajustar_marca(x);\n  }\n\n  private cuando_mueve_el_mouse(datos) {\n    if (this.esta_arrastrando_el_deslizador) {\n      this.ajustar_marca(datos.x);\n    }\n  }\n\n  cuando_termina_de_hacer_click() {\n    this.esta_arrastrando_el_deslizador = false;\n  }\n\n  actualizar() {\n    this.marca.x = this.x - 90 + 1.8 * this.valor;\n    this.marca.y = this.y;\n  }\n\n  private ajustar_marca(x) {\n    let dx = x - this.x;\n\n    // aplica límites porque el deslizador es de unos 180 píxeles.\n    dx = Math.max(dx, -90);\n    dx = Math.min(dx, 90);\n\n    this.valor = (dx + 90) / 1.8;\n  }\n}\n",
      "archivo": "deslizador.ts"
    },
    {
      "nombre": "explosion",
      "codigo": "class explosion extends Actor {\n  propiedades = {\n    figura: \"\",\n    imagen: \"imagenes:explosion/explosion_001\",\n    etiqueta: \"explosion\"\n  };\n\n  iniciar() {\n    this.animacion = \"explosion\";\n    this.pilas.reproducir_sonido(\"explosion\");\n  }\n\n  actualizar() {}\n\n  cuando_finaliza_animacion(nombre: string) {\n    this.eliminar();\n  }\n}\n",
      "archivo": "explosion.ts"
    },
    {
      "nombre": "gallina",
      "codigo": "class gallina extends Actor {\n  propiedades = {\n    x: 0,\n    y: 0,\n    imagen: \"imagenes:gallina/gallina_vuela_3\",\n\n    figura: \"circulo\",\n    figura_radio: 30,\n    figura_sin_rotacion: true,\n    figura_dinamica: true,\n    figura_rebote: 0\n  };\n\n  iniciar() {\n    this.crear_animacion(\n      \"gallina_vuela\",\n      [\n        \"imagenes:gallina/gallina_vuela_1\",\n        \"imagenes:gallina/gallina_vuela_1\",\n        \"imagenes:gallina/gallina_vuela_2\",\n        \"imagenes:gallina/gallina_vuela_3\",\n        \"imagenes:gallina/gallina_vuela_2\"\n      ],\n      15\n    );\n    this.crear_animacion(\"gallina_muere\", [\"imagenes:gallina/gallina_muere\"], 20);\n    this.crear_animacion(\n      \"gallina_sin_piel\",\n      [\"imagenes:gallina/gallina_sin_piel\"],\n      20\n    );\n\n    this.estado = \"vuela\";\n  }\n\n  actualizar() {}\n\n  vuela_iniciar() {\n    this.reproducir_animacion(\"gallina_vuela\");\n  }\n\n  vuela_actualizar() {}\n\n  // # TODO: Implementar este tipo de manejadores, para que desde los estados de autómata se puedan crear colisiones.\n  vuela_cuando_comienza_una_colision(actor) {}\n}\n",
      "archivo": "gallina.ts"
    },
    {
      "nombre": "golpe",
      "codigo": "class golpe extends Actor {\n  propiedades = {\n    figura: \"\",\n    imagen: \"imagenes:efectos/golpe-3\",\n    etiqueta: \"golpe\"\n  };\n\n  iniciar() {\n    this.animacion = \"golpe\";\n  }\n\n  actualizar() {}\n\n  cuando_finaliza_animacion(nombre: string) {\n    this.eliminar();\n  }\n}\n",
      "archivo": "golpe.ts"
    },
    {
      "nombre": "humo",
      "codigo": "class humo extends Actor {\n  propiedades = {\n    figura: \"\",\n    imagen: \"imagenes:efectos/humo-03\",\n    etiqueta: \"humo\"\n  };\n\n  iniciar() {\n    this.animacion = \"humo\";\n  }\n\n  actualizar() {}\n\n  cuando_finaliza_animacion(nombre: string) {\n    this.eliminar();\n  }\n}\n",
      "archivo": "humo.ts"
    },
    {
      "nombre": "laser",
      "codigo": "class laser extends Actor {\n  propiedades = {\n    imagen: \"imagenes:disparos/laser\"\n  };\n\n  velocidad;\n\n  iniciar() {\n    this.centro_x = 0.3;\n    this.velocidad = 10;\n    this.pilas.reproducir_sonido(\"laser\");\n  }\n\n  actualizar() {\n    this.avanzar(this.rotacion, this.velocidad);\n    this.eliminar_si_sale_de_la_pantalla();\n  }\n\n  eliminar_si_sale_de_la_pantalla() {\n    let izquierda = this.pilas.camara.borde_izquierdo;\n    let derecha = this.pilas.camara.borde_derecho;\n    let arriba = this.pilas.camara.borde_arriba;\n    let abajo = this.pilas.camara.borde_abajo;\n\n    if (this.x > derecha || this.x < izquierda || this.y > arriba || this.y < abajo) {\n      this.eliminar();\n    }\n  }\n}\n",
      "archivo": "laser.ts"
    },
    {
      "nombre": "logo",
      "codigo": "class logo extends Actor {\n  propiedades = {\n    imagen: \"imagenes:basicos/logo\"\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "logo.ts"
    },
    {
      "nombre": "moneda",
      "codigo": "class moneda extends Actor {\n  propiedades = {\n    imagen: \"imagenes:objetos/moneda\",\n    etiqueta: \"moneda\",\n    figura: \"circulo\",\n    figura_radio: 10,\n    figura_dinamica: false,\n    figura_sensor: true\n  };\n}\n",
      "archivo": "moneda.ts"
    },
    {
      "nombre": "nave",
      "codigo": "class nave extends Actor {\n  propiedades = {\n    imagen: \"imagenes:nave/nave_reposo\"\n  };\n\n  velocidad = 5;\n  cuadros_desde_el_ultimo_disparo;\n\n  iniciar() {\n    this.animacion = \"nave_en_reposo\";\n    this.cuadros_desde_el_ultimo_disparo = 0;\n  }\n\n  actualizar() {\n    this.cuadros_desde_el_ultimo_disparo += 1;\n\n    if (this.pilas.control.izquierda) {\n      this.rotacion += this.velocidad;\n      this.animacion = \"nave_girando_a_la_izquierda\";\n    }\n\n    if (this.pilas.control.derecha) {\n      this.rotacion -= this.velocidad;\n      this.animacion = \"nave_girando_a_la_derecha\";\n    }\n\n    if (this.pilas.control.espacio && this.cuadros_desde_el_ultimo_disparo > 5) {\n      this.disparar();\n    }\n\n    if (this.pilas.control.arriba) {\n      this.avanzar(this.rotacion, this.velocidad);\n      this.animacion = \"nave_avanzando\";\n    } else {\n      if (!this.pilas.control.izquierda && !this.pilas.control.derecha) {\n        this.animacion = \"nave_en_reposo\";\n      }\n    }\n  }\n\n  disparar() {\n    let laser = this.pilas.actores.laser();\n    laser.x = this.x;\n    laser.y = this.y;\n    laser.rotacion = this.rotacion;\n    laser.z = this.z + 1;\n    this.cuadros_desde_el_ultimo_disparo = 0;\n  }\n}\n",
      "archivo": "nave.ts"
    },
    {
      "nombre": "nube",
      "codigo": "class nube extends Actor {\n  propiedades = {\n    imagen: \"decoracion:objetos/nube\"\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "nube.ts"
    },
    {
      "nombre": "nube_animada",
      "codigo": "class nube_animada extends Actor {\n  propiedades = {\n    imagen: \"decoracion:objetos/decoracion_nube_1\",\n    z: 30\n  };\n\n  velocidad: number;\n\n  iniciar() {\n    this.z = 50;\n    this.velocidad = 2;\n  }\n\n  actualizar() {\n    this.x -= this.velocidad;\n\n    if (this.x < -400) {\n      this.x = 400;\n      this.y = this.pilas.azar(-200, 200);\n    }\n  }\n}\n",
      "archivo": "nube_animada.ts"
    },
    {
      "nombre": "pantalla_completa",
      "codigo": "class pantalla_completa extends Actor {\n  propiedades = {\n    imagen: \"imagenes:botones/pantalla-completa\",\n    es_texto: false,\n    z: -10,\n    transparencia: 50\n  };\n\n  iniciar() {\n    this.transparencia = 50;\n  }\n\n  cuando_hace_click() {\n    this.pilas.alternar_modo_pantalla_completa();\n  }\n\n  cuando_mueve() {\n    this.transparencia = 0;\n  }\n\n  cuando_sale() {\n    this.transparencia = 0;\n  }\n}\n",
      "archivo": "pantalla_completa.ts"
    },
    {
      "nombre": "pared",
      "codigo": "class pared extends Actor {\n  propiedades = {\n    figura: \"rectangulo\",\n    imagen: \"imagenes:plataformas/pared\",\n    y: 0,\n    figura_ancho: 20,\n    figura_alto: 600,\n    figura_dinamica: false,\n    figura_rebote: 0\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "pared.ts"
    },
    {
      "nombre": "pelota",
      "codigo": "class pelota extends Actor {\n  propiedades = {\n    imagen: \"imagenes:objetos/pelota\",\n    figura: \"circulo\",\n    figura_radio: 25\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "pelota.ts"
    },
    {
      "nombre": "pizarra",
      "codigo": "class pizarra extends PizarraBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/sin_imagen\"\n  };\n\n  iniciar() {\n    super.iniciar();\n    this.imagen = \"imagenes:basicos/invisible\";\n\n    this.limpiar();\n\n    // Los colores se puede especificar por componentes (rojo, verde, azul)\n    let color = this.pilas.colores.generar(255, 100, 0);\n    this.dibujar_circulo(100, 0, 40, color);\n    this.dibujar_borde_de_circulo(100, 0, 40, \"negro\", 2);\n\n    // O bien usando nombres.\n    this.dibujar_circulo(100, 100, 20, \"amarillo\");\n    this.dibujar_borde_de_circulo(100, 100, 20, \"negro\", 2);\n\n    // También se pueden dibujar rectángulos, con borde:\n    this.dibujar_rectangulo(-50, -50, 40, 90, \"verde\");\n    this.dibujar_borde_de_rectangulo(-50, -50, 40, 90, \"negro\", 2);\n\n    this.dibujar_linea(-100, 0, 200, 200, \"rojo\", 6);\n  }\n\n  actualizar() {}\n}\n",
      "archivo": "pizarra.ts"
    },
    {
      "nombre": "plataforma",
      "codigo": "class plataforma extends Actor {\n  propiedades = {\n    figura: \"rectangulo\",\n    imagen: \"imagenes:plataformas/plataforma\",\n    etiqueta: \"plataforma\",\n    y: 0,\n    figura_ancho: 250,\n    figura_alto: 40,\n    figura_dinamica: false,\n    figura_rebote: 0\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "plataforma.ts"
    },
    {
      "nombre": "puntaje",
      "codigo": "class puntaje extends ActorTextoBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/invisible\",\n    texto: \"PUNTAJE: 0\",\n    es_texto: true,\n    z: -10,\n    fuente: \"color-blanco-con-sombra-chico\"\n  };\n  puntaje: number = 0;\n\n  iniciar() {\n    this.actualizar_texto();\n  }\n\n  aumentar(cantidad: number = 1) {\n    this.puntaje += cantidad;\n    this.actualizar_texto();\n  }\n\n  actualizar_texto() {\n    this.texto = `PUNTAJE: ${this.puntaje}`;\n  }\n}\n",
      "archivo": "puntaje.ts"
    },
    {
      "nombre": "reiniciar_escena",
      "codigo": "class reiniciar_escena extends ActorTextoBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/invisible\",\n    fondo: \"imagenes:redimensionables/gris\",\n    texto: \"Reiniciar escena\",\n    es_texto: true,\n    z: -10,\n    fuente: \"color-negro\"\n  };\n\n  cuando_hace_click() {\n    this.pilas.reiniciar_escena();\n  }\n\n  cuando_mueve() {\n    this.pilas.definir_cursor(\"pointer\");\n  }\n\n  cuando_sale() {\n    this.pilas.definir_cursor(\"normal\");\n  }\n}\n",
      "archivo": "reiniciar_escena.ts"
    },
    {
      "nombre": "robot",
      "codigo": "class robot extends Actor {\n  propiedades = {\n    imagen: \"imagenes:objetos/robot\",\n    centro_y: 1\n  };\n\n  contenedor: any;\n  huesos: Huesos;\n\n  iniciar() {\n    this.imagen = \"imagenes:basicos/invisible\";\n    this.contenedor = this.pilas.modo.add.container();\n    this.huesos = new Huesos(this.pilas, \"robot\", \"atlas-robot\", this.contenedor);\n    this.huesos.definir_animacion(\"run\");\n  }\n\n  actualizar() {\n    this.huesos.actualizar_animacion(20);\n  }\n\n  pre_actualizar() {\n    this.pilas.utilidades.sincronizar_contenedor(this.contenedor, this.sprite);\n  }\n}\n",
      "archivo": "robot.ts"
    },
    {
      "nombre": "suelo",
      "codigo": "class suelo extends Actor {\n  propiedades = {\n    figura: \"rectangulo\",\n    imagen: \"imagenes:plataformas/suelo\",\n    figura_ancho: 600,\n    figura_alto: 25,\n    figura_rebote: 0,\n    figura_dinamica: false\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "suelo.ts"
    },
    {
      "nombre": "techo",
      "codigo": "class techo extends Actor {\n  propiedades = {\n    figura: \"rectangulo\",\n    imagen: \"imagenes:plataformas/techo\",\n    figura_ancho: 600,\n    figura_alto: 25,\n    figura_dinamica: false\n  };\n\n  iniciar() {}\n}\n",
      "archivo": "techo.ts"
    },
    {
      "nombre": "texto",
      "codigo": "class texto extends ActorTextoBase {\n  propiedades = {\n    imagen: \"imagenes:basicos/invisible\",\n    texto: \"Hola mundo\",\n    es_texto: true,\n    z: -10,\n    fuente: \"color-blanco-con-sombra\"\n  };\n}\n",
      "archivo": "texto.ts"
    }
  ]
}